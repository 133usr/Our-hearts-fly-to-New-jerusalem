{"version":3,"file":"bundle.f335143d839968ecce06.js","mappings":"mBAEyBA,OAAOC,OAAO,CAAC,MAAQ,EAAG,KAAO,IAChCD,OAAOC,OAAO,CAAC,KAAO,EAAG,KAAO,EAAG,MAAQ,G","sources":["webpack://fly_to_mother/./src/cesium_model_animation_player.js"],"sourcesContent":["// const Cesium = require('cesium/Cesium');\r\nimport * as Cesium from 'cesium';\r\nexport const LOOP_TYPE = Object.freeze({\"CLAMP\":1, \"LOOP\":2});\r\nexport const PLAY_STATE = Object.freeze({\"PLAY\":1, \"STOP\":2, \"PAUSE\":3});\r\n\r\nexport class AnimationKey {\r\n  constructor(time, value) {\r\n    this.time = time;\r\n    this.value = value;\r\n  }\r\n};\r\n\r\nexport class AnimationTrack {\r\n  constructor() {\r\n    this.translation_keys = [];\r\n    this.rotation_keys = [];\r\n    this.scale_keys = [];\r\n  }\r\n};\r\n\r\nexport class Animation {\r\n  constructor(name) {\r\n    this.name = name;\r\n    this.duration = 0;\r\n    this.tracks = {}; // a dictionary whose keys are node names\r\n  }\r\n};\r\n\r\nexport class AnimationSet {\r\n  constructor(animations, nodes) {\r\n    this.animations = animations;\r\n    this.nodes = nodes;\r\n  }\r\n};\r\n\r\nexport class AnimationPlayer {\r\n  constructor(animation_set, entity, fps) {\r\n    this.loop_type = LOOP_TYPE.CLAMP;\r\n    this.play_state = PLAY_STATE.STOP;\r\n    this.animation_set = animation_set;\r\n    this.entity = entity;\r\n    if(this.animation_set.animations.length > 0) {\r\n      this.current_animation = this.animation_set.animations[0];\r\n    }\r\n    else {\r\n      this.current_animation = \"\";\r\n    }\r\n\r\n    // set initial node positions for Cesium entity\r\n    let cesium_nodes = {};\r\n\r\n    for(var node_name in this.animation_set.nodes) {\r\n      if(typeof this.entity.model.nodeTransformations != \"undefined\" &&\r\n         typeof this.entity.model.nodeTransformations[node_name] != \"undefined\"){\r\n        cesium_nodes[node_name] = this.entity.model.nodeTransformations[node_name];\r\n      } else {\r\n        cesium_nodes[node_name] = {\r\n          translation: new Cesium.Cartesian3(0, 0, 0),\r\n          rotation: new Cesium.Cartesian4(0, 0, 0, 1),\r\n          scale: new Cesium.Cartesian3(1, 1, 1)\r\n        }\r\n      }\r\n    }\r\n\r\n    this.entity.model.nodeTransformations = cesium_nodes;\r\n    this.interval_id = -1;\r\n    this.current_time = 0;\r\n    this.speed = 1;\r\n    this._frame_duration = 1.0/fps;\r\n  }\r\n\r\n  setAnimation(animation_name) {\r\n    for(var i = 0; i < this.animation_set.animations.length; i++) {\r\n      if(animation_name === this.animation_set.animations[i].name) {\r\n        this.current_animation = this.animation_set.animations[i];\r\n        return;\r\n      }\r\n    }\r\n    console.error(\"Can't set current animation: \" + animation_name + \" does not exist\");\r\n  }\r\n\r\n  setFPS(fps) {\r\n    this._frame_duration = 1.0/fps;\r\n  }\r\n\r\n  play(animation_name) {\r\n    if(typeof animation_name === 'undefined') {\r\n      if(this.play_state === PLAY_STATE.PLAY) {\r\n        return;\r\n      } else if(this.play_state === PLAY_STATE.PAUSE) {\r\n        this.play_state = PLAY_STATE.PLAY;\r\n      } else if(this.play_state === PLAY_STATE.STOP) {\r\n        this.play_state = PLAY_STATE.PLAY;\r\n        this.interval_id = window.setInterval(() => this._update(), this._frame_duration * 1000);\r\n      }\r\n      return;\r\n    }\r\n\r\n    let animations = this.animation_set.animations;\r\n    for(var i = 0; i < animations.length; i++) {\r\n      if(animations[i].name === animation_name) {\r\n        this.current_animation = animations[i];\r\n        if(this.play_state === PLAY_STATE.PLAY) {\r\n          return;\r\n        } else if(this.play_state === PLAY_STATE.PAUSE) {\r\n          this.play_state = PLAY_STATE.PLAY;\r\n        } else if(this.play_state === PLAY_STATE.STOP) {\r\n          this.play_state = PLAY_STATE.PLAY;\r\n          this.interval_id = window.setInterval(() => this._update(), this._frame_duration * 1000);\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    console.error(\"Can't play animation: \" + animation_name + \" does not exist\");\r\n  }\r\n\r\n  _clearUpdateInterval() {\r\n    clearInterval(this.interval_id);\r\n    this.interval_id = -1;\r\n  }\r\n\r\n  _update() {\r\n    if(this.play_state === PLAY_STATE.PLAY)\r\n      this.setTime(this.current_time + this._frame_duration * this.speed);\r\n  }\r\n\r\n  setPercent(percent) {\r\n    if(percent < 0.0) {\r\n      percent = 0.0;\r\n    }\r\n    else if(percent > 1.0) {\r\n      percent = 1.0;\r\n    }\r\n    let time = this.current_animation.duration * percent;\r\n    this.setTime(time);\r\n  }\r\n\r\n  setTime(current_time) {\r\n    this.current_time = current_time;\r\n    if(this.speed > 0) {\r\n      if(this.current_time > this.current_animation.duration) {\r\n        if(this.loop_type === LOOP_TYPE.CLAMP) {\r\n          this.current_time = this.current_animation.duration;\r\n        } else if(this.loop_type === LOOP_TYPE.LOOP) {\r\n          this.current_time = 0;\r\n        }\r\n      }\r\n    } else if(this.speed < 0) {\r\n      if(this.current_time < 0) {\r\n        if(this.loop_type === LOOP_TYPE.CLAMP) {\r\n          this.current_time = 0;\r\n        } else if(this.loop_type === LOOP_TYPE.LOOP) {\r\n          this.current_time = this.current_animation.duration;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    for(var track_name in this.current_animation.tracks) {\r\n      let track = this.current_animation.tracks[track_name];\r\n      let node = this.animation_set.nodes[track_name];\r\n      let curr_trans_keys = this.getKeysAtTime(track.translation_keys, this.current_time);\r\n      let curr_rot_keys = this.getKeysAtTime(track.rotation_keys, this.current_time);\r\n      let curr_scale_keys = this.getKeysAtTime(track.scale_keys, this.current_time);\r\n\r\n      //--------------------------\r\n      // Translation\r\n      //--------------------------\r\n      if(typeof curr_trans_keys !== 'undefined' && curr_trans_keys.length > 0) {\r\n        let orig_trans = node.translation;\r\n        let invMat = node.inv_rotation_matrix;\r\n\r\n        if(curr_trans_keys[0].time == curr_trans_keys[1].time) {\r\n          let result = new Cesium.Cartesian3(curr_trans_keys[0].value[0] - orig_trans[0], curr_trans_keys[0].value[1] - orig_trans[1], curr_trans_keys[0].value[2] - orig_trans[2]);\r\n          //get the result expressed in local node space\r\n          Cesium.Matrix3.multiplyByVector(invMat, result, result);\r\n          this.entity.model.nodeTransformations[track_name].translation = result;\r\n        } else {\r\n          let keyDelta = curr_trans_keys[1].time - curr_trans_keys[0].time;\r\n          let timeDelta = this.current_time - curr_trans_keys[0].time;\r\n          let t = timeDelta/keyDelta;\r\n          let start = new Cesium.Cartesian3(curr_trans_keys[0].value[0], curr_trans_keys[0].value[1], curr_trans_keys[0].value[2]);\r\n          let end = new Cesium.Cartesian3(curr_trans_keys[1].value[0], curr_trans_keys[1].value[1], curr_trans_keys[1].value[2]);\r\n\r\n          //interpolate the translation keys\r\n          let result = new Cesium.Cartesian3();\r\n          Cesium.Cartesian3.lerp(start, end, t, result);\r\n\r\n          //account for delta / relative offset from original translation\r\n          result.x -= orig_trans[0];\r\n          result.y -= orig_trans[1];\r\n          result.z -= orig_trans[2];\r\n\r\n          //get the result expressed in local node space\r\n          Cesium.Matrix3.multiplyByVector(invMat, result, result);\r\n\r\n          this.entity.model.nodeTransformations[track_name].translation = result;\r\n        }\r\n      }\r\n\r\n      //--------------------------\r\n      // Rotation\r\n      //--------------------------\r\n      if(typeof curr_rot_keys !== 'undefined' && curr_rot_keys.length > 0) {\r\n\r\n        let orig_inv = node.inv_rotation;\r\n        let invMat = node.inv_rotation_matrix;\r\n\r\n        if(curr_rot_keys[0].time == curr_rot_keys[1].time) {\r\n          let result = new Cesium.Quaternion(curr_rot_keys[0].value[0], curr_rot_keys[0].value[1], curr_rot_keys[0].value[2], curr_rot_keys[0].value[3]);\r\n\r\n          //isolate the axis\r\n          let resultAxis = new Cesium.Cartesian3(1,0,0);\r\n          let resultAngle = Cesium.Quaternion.computeAngle(result);\r\n          if(Math.abs(resultAngle) > Cesium.Math.EPSILON5)\r\n            Cesium.Quaternion.computeAxis(result, resultAxis);\r\n\r\n          //transform to local node space\r\n          Cesium.Matrix3.multiplyByVector(invMat, resultAxis, resultAxis);\r\n\r\n          //get the new quaternion expressed in local node space\r\n          Cesium.Quaternion.fromAxisAngle(resultAxis, resultAngle, result);\r\n          //calc the rotation delta/difference\r\n          Cesium.Quaternion.multiply(result, orig_inv, result);\r\n          this.entity.model.nodeTransformations[track_name].rotation = result;\r\n        } else {\r\n          let keyDelta = curr_rot_keys[1].time - curr_rot_keys[0].time;\r\n          let timeDelta = this.current_time - curr_rot_keys[0].time;\r\n          let t = timeDelta/keyDelta;\r\n          let start = new Cesium.Quaternion(curr_rot_keys[0].value[0], curr_rot_keys[0].value[1], curr_rot_keys[0].value[2], curr_rot_keys[0].value[3]);\r\n          let end = new Cesium.Quaternion(curr_rot_keys[1].value[0], curr_rot_keys[1].value[1], curr_rot_keys[1].value[2], curr_rot_keys[1].value[3]);\r\n\r\n           //slerp the rotation keys\r\n          let result = new Cesium.Quaternion();\r\n          Cesium.Quaternion.slerp(start, end, t, result);\r\n\r\n          //isolate the axis\r\n          let resultAxis = new Cesium.Cartesian3(1,0,0);\r\n          let resultAngle = Cesium.Quaternion.computeAngle(result);\r\n          if(Math.abs(resultAngle) > Cesium.Math.EPSILON5)\r\n            Cesium.Quaternion.computeAxis(result, resultAxis);\r\n\r\n          //transform to local node space\r\n          Cesium.Matrix3.multiplyByVector(invMat, resultAxis, resultAxis);\r\n\r\n          //get the new quaternion expressed in local node space\r\n          Cesium.Quaternion.fromAxisAngle(resultAxis, resultAngle, result);\r\n\r\n          //calc the rotation delta/difference\r\n          Cesium.Quaternion.multiply(result, orig_inv, result);\r\n\r\n          this.entity.model.nodeTransformations[track_name].rotation = result;\r\n        }\r\n      }\r\n\r\n      //--------------------------\r\n      // Scale\r\n      //--------------------------\r\n      if(typeof curr_scale_keys !== 'undefined' && curr_scale_keys.length > 0) {\r\n        let orig_scale = this.animation_set.nodes[track_name].scale;\r\n\r\n        if(curr_scale_keys[0].time == curr_scale_keys[1].time) {\r\n          let result = new Cesium.Cartesian3(curr_scale_keys[0].value[0] / orig_scale[0], curr_scale_keys[0].value[1] / orig_scale[1], curr_scale_keys[0].value[2] / orig_scale[2]);\r\n          this.entity.model.nodeTransformations[track_name].scale = result;\r\n        } else {\r\n          let keyDelta = curr_scale_keys[1].time - curr_scale_keys[0].time;\r\n          let timeDelta = this.current_time - curr_scale_keys[0].time;\r\n          let t = timeDelta/keyDelta;\r\n          let start = new Cesium.Cartesian3(curr_scale_keys[0].value[0], curr_scale_keys[0].value[1], curr_scale_keys[0].value[2]);\r\n          let end = new Cesium.Cartesian3(curr_scale_keys[1].value[0], curr_scale_keys[1].value[1], curr_scale_keys[1].value[2]);\r\n          let result = new Cesium.Cartesian3();\r\n          Cesium.Cartesian3.lerp(start, end, t, result);\r\n\r\n          //account for delta / relative offset from original scale\r\n          result.x /= orig_scale[0];\r\n          result.y /= orig_scale[1];\r\n          result.z /= orig_scale[2];\r\n          this.entity.model.nodeTransformations[track_name].scale = result;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  getKeysAtTime(keys, time) {\r\n    let result = [];\r\n    if(keys.length == 0)\r\n      return result;\r\n\r\n    //we need to return some value even if the first key for this track isn't reached quite yet\r\n    if(keys[0].time > time) {\r\n      result.push(keys[0]);\r\n      result.push(keys[0]);\r\n      return result;\r\n    }\r\n\r\n    //just clamp the last key if we are at the end\r\n    if(time > keys[keys.length-1].time) {\r\n      result.push(keys[keys.length-1]);\r\n      result.push(keys[keys.length-1]);\r\n      return result;\r\n    }\r\n\r\n    for(var i = 0; i < keys.length-1; i++) {\r\n      if(keys[i].time <= time && keys[i+1].time >= time) {\r\n        result.push(keys[i]);\r\n        result.push(keys[i+1]);\r\n        return result;\r\n      }\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    this.play_state = PLAY_STATE.STOP;\r\n    this.current_time = 0;\r\n    //reset the node transforms on the entity to the default pose\r\n    let cesium_nodes = {};\r\n    for(var node_name in this.animation_set.nodes) {\r\n      cesium_nodes[node_name] = {\r\n        translation: new Cesium.Cartesian3(0, 0, 0),\r\n        rotation: new Cesium.Cartesian4(0, 0, 0, 1),\r\n        scale: new Cesium.Cartesian3(1, 1, 1)\r\n      }\r\n    }\r\n    this.entity.model.nodeTransformations = cesium_nodes;\r\n    this._clearUpdateInterval();\r\n\r\n  }\r\n\r\n  pause() {\r\n    //no need to pause if we are not playing\r\n    if(this.play_state === PLAY_STATE.PLAY)\r\n      this.play_state = PLAY_STATE.PAUSE;\r\n    this._clearUpdateInterval();\r\n  }\r\n}\r\n\r\nexport class AnimationParser {\r\n  static _readFileAsync(file) {\r\n    return new Promise((resolve, reject) => {\r\n      let reader = new FileReader();\r\n\r\n      reader.onload = () => {\r\n        resolve(reader.result);\r\n      };\r\n\r\n      reader.onerror = reject;\r\n\r\n      reader.readAsArrayBuffer(file);\r\n    });\r\n  }\r\n\r\n  static _getResourceAsync(uri) {\r\n    return new Promise((resolve, reject) => {\r\n      var req = new Request(uri);\r\n\r\n      fetch(req).then(function(response) {\r\n        if (!response.ok) {\r\n          reject(new Error(response.statusText));\r\n        }\r\n        return response;\r\n      }).then(function(response) {\r\n          resolve(response.arrayBuffer());\r\n      });\r\n    });\r\n  }\r\n\r\n  static parseAnimationNodesFromArrayBuffer(array_buffer) {\r\n    // get the length of the JSON data starting at 12 byte offset according to gltf standard\r\n    let dv = new DataView(array_buffer, 12, 4);\r\n    // don't forget to set little-endian = true when parsing from data view (gltf standard!)\r\n    let json_chunk_length = dv.getUint32(0, true);\r\n    // console.log(\"gltf JSON length: \" + json_chunk_length + \" bytes\");\r\n\r\n    // get the actual JSON data itself\r\n    let json_data_chunk = array_buffer.slice(20, 20+json_chunk_length);\r\n    let decoder = new TextDecoder('UTF-8');\r\n    let json_text = decoder.decode(json_data_chunk);\r\n    let gltf_json = JSON.parse(json_text);\r\n    // console.log(\"gltf JSON loaded successfully:\");\r\n\r\n    // store links to parent nodes\r\n    for(var i = 0; i < gltf_json.nodes.length; i++) {\r\n      if(typeof gltf_json.nodes[i].children != 'undefined') {\r\n        for(var k = 0; k < gltf_json.nodes[i].children.length; k++) {\r\n          gltf_json.nodes[gltf_json.nodes[i].children[k]].parent = gltf_json.nodes[i].name;\r\n        }\r\n      }\r\n    }\r\n\r\n    return gltf_json.nodes;\r\n  }\r\n\r\n  static parseAnimationsFromArrayBuffer(array_buffer) {\r\n    let animations = [];\r\n\r\n    // get the length of the JSON data starting at 12 byte offset according to gltf standard\r\n    let dv = new DataView(array_buffer, 12, 4);\r\n    // don't forget to set little-endian = true when parsing from data view (gltf tandard!)\r\n    let json_chunk_length = dv.getUint32(0, true);\r\n    // console.log(\"gltf JSON length: \" + json_chunk_length + \" bytes\");\r\n\r\n    // get the actual JSON data itself\r\n    let json_data_chunk = array_buffer.slice(20, 20+json_chunk_length);\r\n    let decoder = new TextDecoder('UTF-8');\r\n    let json_text = decoder.decode(json_data_chunk);\r\n    let gltf_json = JSON.parse(json_text);\r\n    // console.log(\"gltf JSON loaded successfully:\");\r\n    // console.log(gltf_json);\r\n\r\n    // get the length of the gltf embedded binary data\r\n    let bin_offset = 20+json_chunk_length;\r\n    dv = new DataView(array_buffer, bin_offset, 4);\r\n    let bin_chunk_length = dv.getUint32(0, true);\r\n    // console.log(\"gltf bin length: \" + bin_chunk_length + \" bytes\");\r\n\r\n    // get the actual binary data, we add 8 to get past the \"type\" and \"chunk length\" headers\r\n    let bin_data_chunk = array_buffer.slice(bin_offset + 8, bin_offset + 8 + bin_chunk_length);\r\n\r\n    //--------------------------------------------------\r\n    // get and process all animations\r\n    //--------------------------------------------------\r\n    if(typeof gltf_json.animations === 'undefined')\r\n      return [];\r\n    for(var i = 0; i < gltf_json.animations.length; i++) {\r\n      let anim_name = gltf_json.animations[i].name;\r\n      if(typeof anim_name == 'undefined' || anim_name == \"\")\r\n        anim_name = \"animation_\" + i;\r\n      let curr_animation = new Animation(anim_name);\r\n      // console.log(\"processing animation: \" + anim_name);\r\n\r\n      for(var k = 0; k < gltf_json.animations[i].channels.length; k++) {\r\n        let channel = gltf_json.animations[i].channels[k];\r\n\r\n        // the following will be either \"translation, rotation, or scale\"\r\n        let dof_type = channel.target.path;\r\n\r\n        let node = gltf_json.nodes[channel.target.node];\r\n        if(typeof node == 'undefined') {\r\n          console.warn(\"node is undefined for channel \" + k);\r\n          continue;\r\n        }\r\n\r\n        let node_name = node.name;\r\n        if(typeof node_name == 'undefined' || node.name == \"\") {\r\n          node_name = \"node_\" + channel.target.node;\r\n        }\r\n\r\n        // add a new track to this animation for the node if it does not exist already\r\n        if(typeof curr_animation.tracks[node_name] == 'undefined')\r\n          curr_animation.tracks[node_name] = new AnimationTrack();\r\n\r\n        let sampler = gltf_json.animations[i].samplers[channel.sampler];\r\n\r\n        //--------------------------------------------------\r\n        // get input accessor (keyframe times for this channel's sampler) and process the data for it\r\n        //--------------------------------------------------\r\n        let input = gltf_json.accessors[sampler.input];\r\n        //console.log(\"min: \" + input.min + \" max: \" + input.max);\r\n\r\n        let input_accessor_byte_offset =  (typeof input.byteOffset == 'undefined' ? 0 : input.byteOffset);\r\n        if(input.componentType != 5126)\r\n          console.warn(\"input component type is not a float!\");\r\n\r\n        // each element (keyframe timestamp) is a 4 byte float\r\n        let input_element_size = 4;\r\n\r\n        //use the buffer view and accessor to offset into the binary buffer to retrieve our data\r\n        let input_bufferView = gltf_json.bufferViews[input.bufferView];\r\n        let input_accessor_data_offset = input_bufferView.byteOffset + input_accessor_byte_offset;\r\n        let input_bin = bin_data_chunk.slice(input_accessor_data_offset, input_accessor_data_offset + input_element_size * input.count);\r\n        let input_dv = new DataView(input_bin);\r\n\r\n        // parse and store each timestamp out of the buffer\r\n        let timestamps = [];\r\n        for(var j = 0; j < input.count; j++) {\r\n          let timestamp = input_dv.getFloat32(j*4, true);\r\n          if(timestamp > curr_animation.duration) {\r\n            curr_animation.duration = timestamp;\r\n          }\r\n          timestamps.push(timestamp);\r\n        }\r\n\r\n        //--------------------------------------------------\r\n        // get output accessor (keyframe values for this channel's sampler) and process the data for it\r\n        //--------------------------------------------------\r\n        let output = gltf_json.accessors[sampler.output];\r\n\r\n        let output_accessor_byte_offset =  (typeof output.byteOffset == 'undefined' ? 0 : output.byteOffset);\r\n\r\n        // we only care about VEC3 and VEC4 since we are only dealing with rotation, scale, and translation,\r\n        // and we are going to assume they are floating point (componentType = 5126 according to gltf spec)\r\n        if(output.componentType != 5126)\r\n          console.warn(\"output component type is not a float!\");\r\n\r\n        let output_component_count = (output.type == \"VEC3\" ? 3 : 4);\r\n        // 4 byte floats in according to gltf spec\r\n        let output_element_size = output_component_count * 4;\r\n\r\n        //use the buffer view and accessor to offset into the binary buffer to retrieve our value data\r\n        let output_bufferView = gltf_json.bufferViews[output.bufferView];\r\n        let output_accessor_data_offset = output_bufferView.byteOffset + output_accessor_byte_offset;\r\n        let output_bin = bin_data_chunk.slice(output_accessor_data_offset, output_accessor_data_offset + output_element_size * output.count);\r\n        let output_dv = new DataView(output_bin);\r\n\r\n        // parse and store each value\r\n        let values = [];\r\n        for(var j = 0; j < output.count * output_component_count; j += output_component_count) {\r\n          let value = [];\r\n          for(var l = 0; l < output_component_count; l++) {\r\n            value.push(output_dv.getFloat32(j*4 + l*4, true));\r\n          }\r\n          values.push(value);\r\n        }\r\n\r\n        if(dof_type == \"translation\") {\r\n          for(var j = 0; j < output.count; j++) {\r\n            curr_animation.tracks[node_name].translation_keys.push(new AnimationKey(timestamps[j], values[j]));\r\n          }\r\n        } else if(dof_type == \"rotation\") {\r\n          for(var j = 0; j < output.count; j++) {\r\n            curr_animation.tracks[node_name].rotation_keys.push(new AnimationKey(timestamps[j], values[j]));\r\n          }\r\n        } else if(dof_type == \"scale\") {\r\n          for(var j = 0; j < output.count; j++) {\r\n            curr_animation.tracks[node_name].scale_keys.push(new AnimationKey(timestamps[j], values[j]));\r\n          }\r\n        }\r\n      }\r\n      animations.push(curr_animation);\r\n    }\r\n    return animations;\r\n  }\r\n\r\n  static async parseAnimationSetFromUri(glb_uri) {\r\n    let array_buffer = await this._getResourceAsync(glb_uri);\r\n    return this._parseAnimationSetFromArrayBuffer(array_buffer);\r\n  }\r\n\r\n  static async parseAnimationSetFromFile(glb_file) {\r\n    let array_buffer = await this._readFileAsync(glb_file);\r\n    return this._parseAnimationSetFromArrayBuffer(array_buffer);\r\n  }\r\n\r\n  static _parseAnimationSetFromArrayBuffer(array_buffer) {\r\n    let animation_nodes = AnimationParser.parseAnimationNodesFromArrayBuffer(array_buffer);\r\n    // convert nodes to dictionary format\r\n    let nodes_dict = {};\r\n    for(var i = 0; i < animation_nodes.length; i++) {\r\n      nodes_dict[animation_nodes[i].name] = animation_nodes[i];\r\n\r\n      //if the node defines its TRS info as a matrix, we need to capture that (see glTF 2.0 spec)\r\n      if(typeof animation_nodes[i].matrix !== 'undefined') {\r\n        let mat = new Cesium.Matrix4();\r\n        Cesium.Matrix4.fromColumnMajorArray(animation_nodes[i].matrix, mat);\r\n        nodes_dict[animation_nodes[i].name].matrix = mat;\r\n      }\r\n\r\n      //set default values for translation rotation and scale if they do not exist\r\n      if(typeof nodes_dict[animation_nodes[i].name].translation === 'undefined')\r\n        nodes_dict[animation_nodes[i].name].translation = [0,0,0];\r\n\r\n      if(typeof nodes_dict[animation_nodes[i].name].rotation === 'undefined') {\r\n        nodes_dict[animation_nodes[i].name].rotation = [0,0,0,1];\r\n        nodes_dict[animation_nodes[i].name].inv_rotation_matrix = Cesium.Matrix3.IDENTITY;\r\n        nodes_dict[animation_nodes[i].name].inv_rotation = new Cesium.Quaternion(0,0,0,1);\r\n      }\r\n      else {\r\n        //compute and store the inverse rotation matrix and quaternion for future calculations\r\n        let orig_rot = nodes_dict[animation_nodes[i].name].rotation;\r\n        let orig_quat = new Cesium.Quaternion(orig_rot[0], orig_rot[1], orig_rot[2], orig_rot[3]);\r\n        let orig_quat_inv = new Cesium.Quaternion();\r\n        Cesium.Quaternion.inverse(orig_quat, orig_quat_inv);\r\n        let invMat = new Cesium.Matrix3();\r\n        Cesium.Matrix3.fromQuaternion(orig_quat_inv, invMat);\r\n        nodes_dict[animation_nodes[i].name].inv_rotation_matrix = invMat;\r\n        nodes_dict[animation_nodes[i].name].inv_rotation = orig_quat_inv;\r\n      }\r\n\r\n      if(typeof nodes_dict[animation_nodes[i].name].scale === 'undefined')\r\n        nodes_dict[animation_nodes[i].name].scale = [0,0,0];\r\n    }\r\n\r\n    let animations = AnimationParser.parseAnimationsFromArrayBuffer(array_buffer);\r\n    // console.log(nodes_dict);\r\n    return new AnimationSet(animations, nodes_dict);\r\n  }\r\n};"],"names":["Object","freeze"],"sourceRoot":""}